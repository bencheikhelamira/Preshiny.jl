{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Projet Julia et R-Shiny\"\n",
        "format: pdf\n",
        "geometry: \"left=3cm, right=3cm, top=3cm, bottom=3cm\"\n",
        "---\n",
        "\n",
        "\n",
        "# Projet Julia et R-Shiny\n",
        "\n",
        "> **Exploration et Évaluation des Réseaux de Neurones Convolutifs pour la Classification d'Images MNIST**\n",
        "\n",
        "![Logo Julia](julia-logos.png){fig-align=\"center\" width=80%}\n",
        "\n",
        "**Réalisé par :**\n",
        "\n",
        "- **BENCHEIKH El Amira Cerine**\n",
        "- **BELOUARDA Manal**\n",
        "- **MEKKAOUI Sara**\n",
        "\n",
        "**Date :** `r Sys.Date()`\n",
        "\n",
        "# Table des matières\n",
        "\n",
        "- [Introduction](#introduction)\n",
        "- [Le langage Julia](#le-langage-julia)\n",
        "- [Réseaux de Neurones Convolutifs](#réseaux-de-neurones-convolutifs)\n",
        "\n",
        "\\newpage\n",
        "\n",
        "# Introduction\n",
        "\n",
        "## Le langage Julia\n",
        "\n",
        "Julia est un langage de programmation relativement récent, lancé en 2012. Il a été conçu pour répondre aux besoins de calcul scientifique intensif, combinant la rapidité des langages compilés comme C et Fortran avec la facilité d'utilisation et de prototypage de langages interprétés comme Python. Julia est particulièrement apprécié dans le domaine du calcul numérique, de l'analyse de données et de l'intelligence artificielle. Voici quelques points forts de Julia :\n",
        "\n",
        "- **Performance :** Julia est un langage compilé avec des performances proches de celles des langages bas-niveau, notamment grâce à son compilateur JIT (Just-In-Time).\n",
        "- **Syntaxe intuitive :** La syntaxe de Julia est proche de celle de Python, ce qui rend le code plus lisible et accessible.\n",
        "- **Support des opérations sur matrices et calcul scientifique :** Julia est optimisé pour les calculs sur matrices, les opérations vectorielles et le calcul parallèle, ce qui le rend idéal pour le développement d'algorithmes d'apprentissage automatique et de réseaux de neurones.\n",
        "\n",
        "Dans ce projet, nous avons utilisé Julia pour la construction d'un modèle de réseau de neurones convolutifs (CNN) avec le package `Flux.jl`, spécialisé dans les applications de machine learning.\n",
        "\n",
        "## Réseaux de Neurones Convolutifs\n",
        "\n",
        "Les réseaux de neurones convolutifs, ou CNNs, sont une classe de réseaux de neurones spécialement conçus pour le traitement des données sous forme d'images. Ils sont composés de couches convolutives, qui détectent les caractéristiques des images comme les bords, les textures et les formes, et de couches de pooling qui réduisent la dimensionnalité des données tout en conservant leurs informations essentielles.\n",
        "\n",
        "---\n",
        "\n",
        "# Explication des Couches Utilisées dans le Modèle\n",
        "\n",
        "Voici une brève explication des couches que nous utilisons dans notre modèle :\n",
        "\n",
        "- **Couches de Convolution :** Ces couches appliquent des filtres sur les images pour détecter des caractéristiques spécifiques (comme des bords ou des textures).\n",
        "- **Couches de Pooling :** Les couches de pooling réduisent la résolution des images, réduisant ainsi le nombre de paramètres et la complexité computationnelle du modèle.\n",
        "- **Couches Denses :** Ces couches se trouvent en fin de modèle et permettent de faire une classification en combinant les caractéristiques extraites par les couches précédentes.\n",
        "\n",
        "L'image ci-dessous montre le fonctionnement de base d'un CNN :\n",
        "\n",
        "![Schéma d'un réseau de neurones convolutifs](convolutif.png){fig-align=\"center\" width=100%}\n",
        "\n",
        "Les CNNs sont particulièrement efficaces pour la reconnaissance d'images, car ils apprennent à détecter automatiquement les caractéristiques pertinentes sans nécessiter de prétraitement manuel.\n",
        "\n",
        "## Contexte et Objectif du Projet\n",
        "\n",
        "Le projet consiste à utiliser un modèle de réseau de neurones convolutifs pour classifier des images du dataset MNIST, qui est un ensemble d'images de chiffres manuscrits. Le but est de construire et d'entraîner un modèle capable de reconnaître chaque chiffre avec une haute précision.\n",
        "\n",
        "Dans ce projet, nous avons divisé le code en plusieurs parties :\n",
        "\n",
        "- **Préparation des données :** Nous avons chargé et pré-traité les données pour qu'elles soient prêtes pour l'apprentissage. Cela inclut la normalisation et le redimensionnement des images ainsi que l'encodage des labels en one-hot.\n",
        "- **Construction du modèle CNN :** Le modèle utilise des couches convolutives et des couches de pooling pour extraire les caractéristiques des images, suivies de couches denses pour la classification finale.\n",
        "- **Entraînement et Évaluation :** Nous avons configuré une fonction d'entraînement qui utilise un optimiseur `Adam` pour ajuster les poids du modèle en minimisant la fonction de perte de cross-entropie. Nous avons également calculé des métriques de précision, de rappel et de F1-score pour évaluer les performances du modèle.\n",
        "\n",
        "Ce projet illustre comment les réseaux de neurones convolutifs peuvent être appliqués pour résoudre des problèmes de classification d'images et comment Julia et `Flux.jl` facilitent leur implémentation.\n",
        "\n",
        "## Les Bénéfices de Julia dans le Machine Learning\n",
        "\n",
        "Julia présente plusieurs avantages par rapport à d'autres langages comme Python dans le contexte du Machine Learning :\n",
        "\n",
        "- **Performance :** Julia est extrêmement rapide, proche du langage C, ce qui permet une exécution plus rapide lors de l'entraînement des modèles de Machine Learning.\n",
        "- **Facilité d'utilisation :** Julia combine la simplicité de Python avec la performance des langages compilés.\n",
        "- **Interopérabilité :** Julia peut facilement interagir avec d'autres langages comme Python, ce qui permet de profiter des bibliothèques existantes tout en tirant parti de la rapidité de Julia.\n",
        "\n",
        "![Graphique comparatif des performances](1_WEijeS2RWVLIGbfYQOlrzw.png){fig-align=\"center\" width=70%}\n",
        "\n",
        "\n",
        "# Comparaison entre Julia et Python\n",
        "\n",
        "Bien que Python soit largement utilisé dans le Machine Learning, Julia offre des avantages significatifs :\n",
        "\n",
        "- **Python** dispose d'un écosystème riche, avec des bibliothèques comme TensorFlow et PyTorch.\n",
        "- **Julia**, bien qu'ayant un écosystème plus petit, est beaucoup plus rapide, surtout pour les calculs numériques lourds.\n",
        "\n",
        "![Comparaison des temps d'exécution entre Julia et Python](ok.png)\n",
        "\n",
        "# Inconvénients de Julia\n",
        "\n",
        "Bien que Julia offre de nombreux avantages, il existe quelques inconvénients :\n",
        "\n",
        "- L'écosystème est encore en développement et ne rivalise pas encore avec Python en termes de nombre de bibliothèques disponibles.\n",
        "- La communauté est plus petite, ce qui signifie moins de ressources et d'exemples disponibles.\n",
        "\n",
        "# Préparation des Données\n",
        "\n",
        "## Décortiquer les Données\n",
        "\n",
        "Avant de pouvoir entraîner notre modèle, nous devons charger et examiner les données pour comprendre leur structure, comme indiqué ci-dessous :\n",
        "\n",
        "```julia\n",
        "X_train, y_train = load_data(\"train_data.csv\")\n",
        "X_test, y_test = load_data(\"test_data.csv\")\n",
        "\n",
        "## Normalisation des Données\n",
        "\n",
        "La normalisation consiste à ajuster les valeurs des pixels (qui sont souvent entre 0 et 255 dans le cas des images) pour qu'elles soient dans une gamme plus petite, typiquement entre 0 et 1. Cela permet de stabiliser l'entraînement en réduisant les fluctuations importantes des gradients.\n",
        "\n",
        "La normalisation doit être effectuée avant de passer les données dans le réseau de neurones, car les modèles de Machine Learning, et en particulier les réseaux de neurones, fonctionnent mieux lorsque les données sont sur une échelle comparable. Typiquement, cela se fait juste après le chargement des données et avant la phase d'entraînement.\n",
        "\n",
        "## Pourquoi la normalisation est importante ?\n",
        "\n",
        "- **Stabilité du Gradient** : Lors de l'entraînement du réseau de neurones, des valeurs de pixels très élevées (comme 255 pour les images) peuvent entraîner une explosion des gradients pendant la rétropropagation. Normaliser ces valeurs à une échelle plus petite comme [0, 1] permet de maintenir les gradients plus stables et favorise une convergence plus rapide.\n",
        "- **Performance de l'Optimiseur** : Les optimiseurs comme Adam dans notre cas fonctionnent mieux lorsque les entrées sont sur des échelles similaires, ce qui accélère l'entraînement et peut conduire à de meilleures performances.\n",
        "\n",
        "## Canaux des Données\n",
        "\n",
        "Dans le contexte des réseaux de neurones pour la reconnaissance d'images, les canaux (ou channels) font référence aux différentes couches de couleurs d'une image. Prenons l'exemple des images RGB (Rouge, Vert, Bleu), qui sont les plus courantes pour les images colorées.\n",
        "\n",
        "## Qu'est-ce que les canaux d'une image ?\n",
        "\n",
        "- **Image en niveaux de gris** : Une image en noir et blanc a un seul canal, car chaque pixel est décrit par une seule valeur représentant l'intensité lumineuse (de noir à blanc).\n",
        "- **Image RGB** : Une image en couleur est souvent composée de trois canaux : Rouge (R), Vert (G) et Bleu (B). Chaque pixel dans une image RGB a donc trois valeurs, une pour chaque couleur. Chaque couleur est représentée par une intensité (souvent entre 0 et 255, où 0 est l'absence de couleur et 255 est la couleur maximale).\n",
        "\n",
        "![Comprendre le réseau CNN](1_UN1oMSV2qWdDzjoZILKCRg.png){fig-align=\"center\" width=40%}\n",
        "\n",
        "Dans notre projet, notre modèle de réseau de neurones convolutifs (CNN) travaille avec des images en RGB. Chaque couche de convolution traitera les trois canaux de l'image. Lorsqu'on passe les images dans le modèle, il est crucial que les dimensions des données (en particulier le nombre de canaux) soient correctement prises en compte, car chaque couche de convolution appliquera des filtres à chacun des canaux (R, G, B) pour extraire des caractéristiques.\n",
        "\n",
        "```{figure}\n",
        "  ![How channels (RGB) effect convolutional neural network](CNN_Fundamentals.png)\n",
        "  :width: 60%\n",
        "  :caption: \"How channels (RGB) effect convolutional neural network\"\n",
        "\n",
        "\\newpage\n",
        "\n",
        "## Encodage des Labels\n",
        "Le terme \"labels\" fait référence aux étiquettes de classe pour chaque image dans les ensembles de données d'entraînement et de test. Ces étiquettes sont essentielles pour la classification d'images, car elles représentent la classe correcte à laquelle une image appartient. Par exemple, dans le cas du dataset MNIST, chaque image représente un chiffre (0 à 9), et l'étiquette correspond à ce chiffre.\n",
        "\n",
        "## Chargement des labels :\n",
        "Lorsque vous chargez les données MNIST avec la fonction MNIST.traindata() et MNIST.testdata(), vous obtenez à la fois les images (train_X et test_X) et leurs labels correspondants (train_y et test_y). Ces labels indiquent quel chiffre est représenté sur chaque image. \\ Par exemple, si une image correspond au chiffre \"3\", alors l'étiquette pour cette image sera \"3\".\n",
        "\n",
        "  ![Labels des images](0_9jCey4wywZ4Os7hF.png)\n",
        "  :width: 90%\n",
        "  :caption: \"Labels des images\""
      ],
      "id": "132f124b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}